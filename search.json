[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Andrew McNeil. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McNeil (2022). maybe: Maybe Monad R. R package version 0.0.0.9000.","code":"@Manual{,   title = {maybe: The Maybe Monad in R},   author = {Andrew McNeil},   year = {2022},   note = {R package version 0.0.0.9000}, }"},{"path":[]},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"The Maybe Monad in R","text":"can install development version GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"armcn/maybe\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"The Maybe Monad in R","text":"Maybe values can used model computations may fail undefined outputs. example, dividing zero mathematically undefined many programming languages, including R, return infinity. can cause unexpected problems later program. can use maybe value make safe divide function. time 2 / 2 returns Just 1 2 / 0 returns Nothing. two possibly values maybe value. can Just value, can Nothing (absence value). maybe value used another function, first need specify happen function returns Nothing. can done using with_default function. function return value contained Just, Nothing return default. Think maybe value container. container can Just value Nothing. use contained value regular R functions need unwrap first. gets interesting chain maybe values together. Instead use with_default every time use function produces maybe values, can chained with_default needs called end. example, may want divide two numbers get absolute value result. accomplished map_maybe function. map_maybe, often called fmap languages, reaches maybe value, applies function value, re-wraps result maybe. input Just value, return value map_maybe also Just. Nothing return value Nothing. wanted chain multiple “safe” functions (functions return maybe values) together? use and_then. function often called bind languages. First let’s define two “safe” functions call one . Functions can also converted “safe” functions another way. Instead rewriting function can wrap function maybe. modify function return Nothing error warning can optionally provide predicate function (function returns TRUE FALSE) assert something result. example functions made “safe” maybe function. automatically capture errors warnings return Nothing. Warnings can allowed setting allow_warnings = TRUE. pattern wrapping function maybe function setting default value common shortcut, perhaps. default value set otherwise parameter. function always return regular R values, maybes. can combine multiple predicates /functions. use predefined combinations like not_undefined checks output NULL, NA, NaN, -Inf, Inf.","code":"library(maybe)  safe_divide <- function(a, b) {   if (b == 0) nothing() else just(a / b) }  2 / 2 #> [1] 1 safe_divide(2, 2) #> Just #> [1] 1  2 / 0 #> [1] Inf safe_divide(2, 0) #> Nothing safe_divide(2, 2) #> Just #> [1] 1 safe_divide(2, 2) |> with_default(0) #> [1] 1  safe_divide(2, 0) #> Nothing safe_divide(2, 0) |> with_default(0) #> [1] 0 safe_divide(-2, 2) #> Just #> [1] -1 safe_divide(-2, 2) |> map_maybe(abs) #> Just #> [1] 1  safe_divide(-2, 0) #> Nothing safe_divide(-2, 0) |> map_maybe(abs) #> Nothing safe_mean <- function(a) {   if (length(a) == 0L) nothing() else just(mean(a)) }  safe_sqrt <- function(a) {   if (a == -1) nothing() else just(sqrt(a)) }  safe_mean(1:10) |> and_then(safe_sqrt) #> Just #> [1] 2.345208 safe_mean <- maybe(mean, result = not_nan) safe_sqrt <- maybe(sqrt, result = not_infinite)  safe_mean(\"hello\") |> and_then(safe_sqrt) #> Nothing safe_mean(1:10) |> and_then(safe_sqrt) #> Just #> [1] 2.345208 safe_mean <- maybe(mean)  safe_mean(1:10) #> Just #> [1] 5.5 safe_mean(\"hello\") #> Nothing  safe_mean <- maybe(mean, allow_warning = TRUE)  safe_mean(\"hello\") #> Warning in mean.default(...): argument is not numeric or logical: returning NA #> [1] NA safe_mean <- perhaps(mean, otherwise = 0)  safe_mean(1:10) #> [1] 5.5 safe_mean(\"hello\") #> [1] 0 safe_mean <- maybe(mean, result = and(not_nan, not_empty))  safe_mean(1:10) #> Just #> [1] 5.5 safe_mean <- maybe(mean, result = not_undefined)  safe_mean(c(1, 2, 3)) #> Just #> [1] 2 safe_mean(c(NA, 2, 3)) #> Nothing"}]
